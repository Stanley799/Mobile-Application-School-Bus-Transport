package com.example.schoolbustransport.data.repository\n\nimport com.example.schoolbustransport.domain.model.Trip\nimport com.example.schoolbustransport.domain.model.TripStatus\nimport com.example.schoolbustransport.domain.repository.TripRepository\nimport com.google.firebase.firestore.FieldValue\nimport com.google.firebase.firestore.FirebaseFirestore\nimport kotlinx.coroutines.channels.awaitClose\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.callbackFlow\nimport kotlinx.coroutines.tasks.await\nimport javax.inject.Inject\n\nclass TripRepositoryImpl @Inject constructor(\n    private val firestore: FirebaseFirestore\n) : TripRepository {\n\n    override fun getTrips(): Flow<List<Trip>> = callbackFlow {\n        val listenerRegistration = firestore.collection(\"trips\")\n            .addSnapshotListener { snapshot, error ->\n                if (error != null) {\n                    close(error)\n                    return@addSnapshotListener\n                }\n                if (snapshot != null) {\n                    val trips = snapshot.toObjects(Trip::class.java)\n                    trySend(trips)\n                }\n            }\n        awaitClose { listenerRegistration.remove() }\n    }\n\n    override fun getTripDetails(tripId: String): Flow<Trip?> = callbackFlow {\n        val listenerRegistration = firestore.collection(\"trips\").document(tripId)\n            .addSnapshotListener { snapshot, error ->\n                if (error != null) {\n                    close(error)\n                    return@addSnapshotListener\n                }\n                if (snapshot != null && snapshot.exists()) {\n                    val trip = snapshot.toObject(Trip::class.java)\n                    trySend(trip)\n                } else {\n                    trySend(null)\n                }\n            }\n        awaitClose { listenerRegistration.remove() }\n    }\n\n    override suspend fun startTrip(tripId: String): Result<Unit> {\n        return try {\n            firestore.collection(\"trips\").document(tripId).update(\"status\", TripStatus.IN_PROGRESS).await()\n            Result.success(Unit)\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n\n    override suspend fun endTrip(tripId: String): Result<Unit> {\n        return try {\n            firestore.collection(\"trips\").document(tripId).update(\"status\", TripStatus.COMPLETED).await()\n            Result.success(Unit)\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n\n    override suspend fun markAttendance(tripId: String, studentId: String, status: String): Result<Unit> {\n        return try {\n            // This is a simplified example. In a real app, you would have a more robust way of storing attendance.\n            firestore.collection(\"trips\").document(tripId).update(\"attendance.\$studentId\", status).await()\n            Result.success(Unit)\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n}\n