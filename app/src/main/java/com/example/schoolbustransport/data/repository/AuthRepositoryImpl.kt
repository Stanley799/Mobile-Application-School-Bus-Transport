package com.example.schoolbustransport.data.repository\n\nimport com.example.schoolbustransport.domain.model.User\nimport com.example.schoolbustransport.domain.model.UserRole\nimport com.example.schoolbustransport.domain.repository.AuthRepository\nimport com.google.firebase.auth.FirebaseAuth\nimport com.google.firebase.firestore.FirebaseFirestore\nimport kotlinx.coroutines.channels.awaitClose\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.callbackFlow\nimport kotlinx.coroutines.tasks.await\nimport javax.inject.Inject\n\nclass AuthRepositoryImpl @Inject constructor(\n    private val firebaseAuth: FirebaseAuth,\n    private val firestore: FirebaseFirestore\n) : AuthRepository {\n\n    override fun getFirebaseUserFlow(): Flow<com.google.firebase.auth.FirebaseUser?> = callbackFlow {\n        val authStateListener = FirebaseAuth.AuthStateListener { auth ->\n            trySend(auth.currentUser)\n        }\n        firebaseAuth.addAuthStateListener(authStateListener)\n        awaitClose { firebaseAuth.removeAuthStateListener(authStateListener) }\n    }\n\n    override suspend fun login(email: String, password: String): Result<User> {\n        return try {\n            val authResult = firebaseAuth.signInWithEmailAndPassword(email, password).await()\n            val firebaseUser = authResult.user!!\n            \n            // Fetch user data from Firestore\n            val userDoc = firestore.collection(\"users\").document(firebaseUser.uid).get().await()\n            val user = userDoc.toObject(User::class.java)!!\n\n            Result.success(user)\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n\n    override suspend fun register(name: String, email: String, phone: String, password: String, role: String): Result<User> {\n        return try {\n            val authResult = firebaseAuth.createUserWithEmailAndPassword(email, password).await()\n            val firebaseUser = authResult.user!!\n\n            val user = User(\n                id = firebaseUser.uid,\n                name = name,\n                email = email,\n                phone = phone,\n                role = UserRole.fromString(role) // Assuming UserRole has a fromString method\n            )\n\n            // Save user data to Firestore\n            firestore.collection(\"users\w\").document(firebaseUser.uid).set(user).await()\n\n            Result.success(user)\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n\n    override fun getLoggedInUser(): Flow<User?> = callbackFlow {\n        val authStateListener = FirebaseAuth.AuthStateListener { auth ->\n            val firebaseUser = auth.currentUser\n            if (firebaseUser != null) {\n                // This is not efficient, but demonstrates the concept.\n                // In a real app, you would fetch the user from a local cache or a single snapshot listener.\n                firestore.collection(\"users\").document(firebaseUser.uid).get()\n                    .addOnSuccessListener { document ->\n                        val user = document.toObject(User::class.java)\n                        trySend(user)\n                    }\n                    .addOnFailureListener { trySend(null) }\n            } else {\n                trySend(null)\n            }\n        }\n        firebaseAuth.addAuthStateListener(authStateListener)\n        awaitClose { firebaseAuth.removeAuthStateListener(authStateListener) }\n    }\n\n    override suspend fun logout() {\n        firebaseAuth.signOut()\n    }\n}\n